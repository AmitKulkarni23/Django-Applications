Render Data from the Database with a Model


from products.model import Product

$ Product.objects.get(id = 1)

$ obj.title -> ALlows you to grab data from database


Django -> auto incremented id
(check in migrations -> id is a AutoField)

Create a view in products/views.py
Create a template

def product_detail_view(request):
    obj = Product.objects.get(id=1)
    context = {
        'title': obj.title,
        'description': obj.description
    }
    return render(request, "product/detail.html", context)
	

But this contxt is highly dependent on the object
Therefore, use something as below


def product_detail_view(request):
    obj = Product.objects.get(id=1)
    context = {
        'object': obj
    }
    return render(request, "product/detail.html", context)



------------------------------

How Django Templates load with Apps

Keep everything about an app inside that app - Best practice
Reusability

But what about templates?


Inside of your app you can have a folder called as templates

So whenever you get a template is not present look at the Template Loader

Template Loader:
- first looks at the file system loader for the specific template(*.html) file
- Next site-packages\django\contrib\admin\templates\products
- Next ite-packages\django\contrib\auth\templates\products
- Next TryDjango\src\products\templates\products\detail.html



------------------------------

Django Model Forms


- Allow users to save data into database

forms.py -> Inside any app


form.as_p -> This is a built-in Django thing which converts the form that we are actually passing into a 
HTML form with <p> tags

------------------------------

RAW HTML Form



GET -> is the default method for a form
Similar to search on a website



CSRF verification failed -> Security measures that Django has built-in

action -> in an input form means that you can send the data to a URL
method -> POST / GET


GET -> your are getting information from a URL
POST -> When you want to save information to backend you use POST


request.GET
request.POST

<form action='http://www.google.com/search method="GET">
    <input type='text' name='q' placeholder="Your Search">
    <input type='submit' value="Save"/>
</form>

------------------------------


Pure Django Form
- for validation errors


form.as_p
form.as_ul

------------------------------

Form Widgets

- Working with individual fields in a form


class RawProductForm(forms.Form):
    title = forms.CharField(label='', widget=forms.TextInput(attrs={"placeholder" : "Enter your title"}))
    description = forms.CharField(required=False, widget=forms.Textarea(
        attrs={
            "placeholder":"Enter your description",
            "class": "my-description-class",
            "rows": 10,
            "cols": 20,
            "id": "my-description-id",
    }))
    price = forms.DecimalField(initial=1.99)

	
------------------------------



Form validation Methods

- Django has a built-in validation for its fields

------------------------------

Initial Data on a form


initial = {
	"title" : "Initial Title"
	}
	
form = RawProductForm(request.POST or None, initial = initial)
context = {
	"form" : form,
}

return render(request, "products/product_create.html", context}



Can initialize the data to be from data from one of the objects in the database

obj = Product.objects.get(id = 1)
form = RawProductForm(request.POST or None, initial = obj)
if form.is_valid():
	form.save()
	# Note the object with id = 1 will be changed with whatever fields taht you enter here
context = {
	"form" : form,
}

return render(request, "products/product_create.html", context}

------------------------------


Dynamic URL Routing


In urls.py
path('dynamic/<int:id>/', dynamic_lookup_view)

In views.py
def dynamic_lookup_view(request, id):
    obj = Product.objects.get(id=id)
    context = {
        "object" : obj
    }
    return render(request, "products/product_detail.html", context)
	
	
------------------------------


Handle DoesNotExist

- Handling a missing object from a dynamic URL

1st way:
from django.shortcuts import render, get_object_or_404
obj = get_object_or_404(Product, id=id)


2nd way:
from django.http import Http404
try:
	obj = Product.object.get(id=id)
except Product.DoesNotExist:
	raise Http404
	

------------------------------

Delete and Confirm

if request.method == "POST"
	obj.delete()	
	return redirect("../../")
	
	
------------------------------

View of a list of database objects

queryset = Product.objects.all()

------------------------------

Dynamic Linking of URLs


Creating links to products -> Need to create an instance method on our model

------------------------------

Django URLs Reverse


make our method in models ( get_absolute_url ) completely dynamic


from django.urls import reverse


Call the name of the URL that will handle this data
reverse("product-detail", kwargs={"id" : self.id})


------------------------------

In App Urls and namespacing

Suppose you have some urlpatterns as below:

path('dynamic/<int:id>/', dynamic_lookup_view, name="product-detail"),
path('products/<int:id>/', product_detail_view, name="product-detail"),

The names here are same.
So in the list of database objects, if I click on a particular product, would
the url change to /products/<id>/ or dynamic/<id>


This is where namespacing comes in




